/* Reverse polish notation calculator.  */
%{
  #include <stdio.h>
  #include <iostream>
  #include "newParser.hpp"
  
  using namespace std;
  
  int yylex (void);
  void yyerror (char const *);
  void semanticError(string s);
%}

%token NUM 
%token Defstruct Extern Main Var Integer Real If Then While Do Return Write Read Call
%token Else 
%token ID
%token STRING
%token ',' ';' ':'

%right ASSIGN
%left OR_OP
%left AND_OP
%left REL_OP
%left ADD_OP
%left MUL_OP
%right NOT_OP
%left '[' '{' '('
%right ']' '}' ')'
%%

PROGRAM: 
		TDEFS FDEFS MAIN_FUNCTION {
		}
;
TDEFS: 
		TDEFS Defstruct '{' DECLARLIST '}' ID ';' {
		  addStructToSymbolTable($6->tokenValue, $4->declarationList);
		}		
	|
		/*epsilon*/ { cout << "TDEFS to e" << endl; }
;		
FDEFS: 
		FDEFS TYPE ID '(' FUNC_ARGLIST_FULL ')' BLK {
		  cout << "FDEFS: " << $3->tokenValue << endl;
		  Function* func = new Function($3->tokenValue, $5->argsList);
		  func->insertSymbolTable($7->declarationList);
		  funcSymbols.insert(std::pair<string, Function>($3->tokenValue, *func));
		}
	|
		FDEFS Extern TYPE ID '(' FUNC_ARGLIST_FULL ')' ';' {
		  Function* func = new Function($4->tokenValue, $6->argsList);
		  funcSymbols.insert(std::pair<string, Function>($4->tokenValue, *func));
		}		
	|
		/*epsilon*/ { cout << "FDEFS to e" << endl;}
;
FUNC_ARGLIST_FULL: 
		FUNC_ARGLIST {
		  $$->argsList = $1->argsList;
		}
	|
		/*epsilon*/ {}
;		
FUNC_ARGLIST: 
		FUNC_ARGLIST ',' DCL {
		  createArgumentsFromDCL($3, $1);
		  $$->argsList = $1->argsList;
		}
	|
		DCL {
		  createArgumentsFromDCL($1, $$);
		}
;
MAIN_FUNCTION:
		Main {currFunction = new Function("main"); currBlock = currFunction;} BLK {
			Function* mainFunc = currFunction;
			mainFunc->insertSymbolTable($2->declarationList);
			funcSymbols.insert(std::pair<string, Function>("main", *mainFunc));
			cout << "MAIN_FUNCTION" <<endl;
		} 
	|
		/*epsilon*/ {}
;		
BLK: 
		DECLARATIONS '{' LIST '}' {
			$$->declarationList = $1->declarationList;
			$3->declarationList = $1->declarationList;
			cout << "BLK" << endl;
		}
;	
DECLARATIONS:
		Var DECLARLIST {
			cout << "DECLARATIONS" << endl;
			// add declerations to current block
			currBlock->insertSymbolTable($2->declarationList);
			$$->declarationList = $2->declarationList;
		} // the symbol table insertions are made during DECLARLIST parsing
	|
		/*epsilon*/ { cout << "DECLARATIONS to e" << endl; }
;		
DECLARLIST:
		DECLARLIST DCL ';' {
			cout << "DECLARLIST1: " << $2->dcl_type << endl;
		  createVariablesFromDCL($2, $1);
		  $$->declarationList = $1->declarationList;
		}
	|
		DCL ';' {
			cout << "DECLARLIST2: " << $1->dcl_type << endl;
		  // $$.declarationList = new
		  createVariablesFromDCL($1, $$);
		}
;		
DCL: 
		ID ':' TYPE {
		  cout << "variable "+ $1->tokenValue +" of type "+ $3->tokenValue +" declared" << endl;
		  $$->dcl_type = $3->tokenValue;
		  ($$->dcl_ids).push_front($1->tokenValue);
		} 
	|
		ID ':' ID {
			if(validateStructName($3->tokenValue) == false){
			  semanticError("illegal type name");
			}
		    $$->dcl_type = $3->tokenValue;
		    ($$->dcl_ids).push_front($1->tokenValue);
		  //The 2nd ID might be the name of a custom typedef
		}
	|
		ID ',' DCL {
		  ($3->dcl_ids).push_front($1->tokenValue);
		  ($$->dcl_ids).merge($3->dcl_ids);
		  $$->dcl_type = $3->dcl_type;
		}
;	
TYPE: 
		Integer { 
		} // $$->tokenValue is already assigned in .lex file
	|
		Real {
		} // $$->tokenValue is already assigned in .lex file
;	
LIST: 
		LIST STMT {
		}
	|
		/*epsilon*/ {}
;	
STMT: 
		ASSN {
		}
	|
		CNTRL {
		}
	|
		READ {
		}
	|
		WRITE {
		}
	|
		STMT_RETURN {
		}
	|
		BLK {
		}
;	
STMT_RETURN: 
		Return '(' EXP ')' ';' {		}
;	
WRITE: 
		Write '(' EXP ')' ';' {
		}
	|
		Write '(' STRING ')' ';' {
		}
;	
READ: 
		Read '(' LVAL ')' ';' {
		}
;	
ASSN: 
		LVAL ASSIGN EXP ';' {
		  string tempreg = getIntReg();
		  // assert leagal assignment
		  string dest = $1->place;
		  string src = $3->place;
		  if(dest[0] != src[0]) {
		    semanticError("type mismatch on assignment: can't assign " + dest + " to " + src);
		  }
		  // dest holds LVAL's address in memory
		  if(dest[0] == 'I') {
		    emit("STORI " + src + " " + dest + " 0 ");
		  }
		  else {
		    emit("STORR " + src + " " + dest + " 0 ");
		  }
		}
;
LVAL: 
		ID {
		  // make sure ID is a variable in current scope
		  Variable* var = currBlock->getScopeVariable($1->tokenValue);
		  if(var == NULL) {
		    cout << "currFunction: " << currFunction->name << endl;
		    printState();
		    semanticError($1->tokenValue + " was not declared in this scope");
		  }
		  
		  string tempreg = getIntReg();
		  $$->place = tempreg;
		  string LOAD = "";
		  if(var->getType() == "integer") {
		    LOAD = "LOADI";
		  }
		  else if(var->getType() == "real") {
		    LOAD = "LOADR";
		  }
		  else {
		    // TODO: implement struct copy (load address in memory instead of value)
		  }
		  // load variable into a register
		  emit(LOAD + " " + tempreg + " I1 " + std::to_string(var->getOffset()));
		}
	|
		STREF {
		}
;
CNTRL: 
		If BEXP Then M STMT N Else M STMT {
		  backpatch($2->trueList, $4->quad);
		  backpatch($2->falseList, $8->quad);
		  $$->nextList.insert($$->nextList.end(), $5->nextList.begin(), $5->nextList.end());
		  $$->nextList.insert($$->nextList.end(), $6->nextList.begin(), $6->nextList.end());
		  $$->nextList.insert($$->nextList.end(), $9->nextList.begin(), $9->nextList.end());
		}
	|
		If BEXP Then M STMT N{
		  backpatch($2->trueList, $4->quad);
		  $$->nextList.insert($$->nextList.end(), $2->falseList.begin(), $2->falseList.end());
		  $$->nextList.insert($$->nextList.end(), $5->nextList.begin(), $5->nextList.end());
		}
	|
		While M BEXP Do M STMT {
		  backpatch($3->trueList, $5->quad);
		  backpatch($5->nextList, $2->quad);
		  $$->nextList.insert($$->nextList.end(), $3->falseList.begin(), $3->falseList.end());
		  emit((string)"UJUMP " + INT2STR($2->quad));
		}
;	
BEXP: 
		BEXP OR_OP M BEXP {
		  backpatch($1->falseList, $3->quad);
		  $$->trueList.insert($$->trueList.end(), $1->trueList.begin(), $1->trueList.end());
		  $$->trueList.insert($$->trueList.end(), $4->trueList.begin(), $4->trueList.end());
		  $$->falseList.insert($$->falseList.end(), $4->falseList.begin(), $4->falseList.end());
		}
	|
		BEXP AND_OP M BEXP {
		  backpatch($1->trueList, $3->quad);
		  $$->falseList.insert($$->falseList.end(), $1->falseList.begin(), $1->falseList.end());
		  $$->falseList.insert($$->falseList.end(), $4->falseList.begin(), $4->falseList.end());
		  $$->trueList.insert($$->trueList.end(), $4->trueList.begin(), $4->trueList.end());
		}
	|
		EXP REL_OP EXP {
		  string tempReg = getIntReg();
		  string SLET = "";
		  string SGRT = "";
		  string SEQU = "";
		  string SNEQ = "";
		  string opCommand = "";
		  
		  if(isIntegerVariable($1->place) && isIntegerVariable($3->place)) {
		    SLET = "SLETI";
		    SGRT = "SGRTI";
		    SEQU = "SEQUI";
		    SNEQ = "SNEQI";
		  } else if(isRealVariable($1->place) && isRealVariable($3->place)) {
		    SLET = "SLETR";
		    SGRT = "SGRTR";
		    SEQU = "SEQUR";
		    SNEQ = "SNEQR";		    
		  } else {
		    semanticError("type missmatch on relop \'" + $2->tokenValue + "\'");
		  }
		  
		  if($2->tokenValue == "<" || $2->tokenValue == "<=") {
		    opCommand = SLET;
		  } else if($2->tokenValue == ">" || $2->tokenValue == ">=") {
		    opCommand = SGRT;
		  } else if($2->tokenValue == "==") {
		    opCommand = SEQU;
		  } else if($2->tokenValue == "<>") {
		    opCommand = SNEQ;
		  } else {
		    semanticError("can't recognize RELOP " + $2->tokenValue);
		  }
		  
		  bool equalsFlag = false;
		  if($2->tokenValue == "<=" || $2->tokenValue == ">=") {
		    equalsFlag = true;
		  }
		  
		  emit(opCommand + " " + tempReg + " " + $1->place + " " + $3->place);
		  $$->trueList.push_back(nextquad());
		  emit("BNEQZ " + tempReg + " ___");
		  if(equalsFlag) {
		    // if tempReg == 0 we should continue down the flow (no jump needed)
		    emit(SEQU + " " + tempReg + " " + $1->place + " " + $2->place);
		    $$->trueList.push_back(nextquad());
		    emit("BNEQZ " + tempReg + " ___");
		  }
		  $$->falseList.push_back(nextquad());
		  emit((string)"UJUMP " + "___");
		}

	|
		NOT_OP BEXP {
		  $$->trueList.swap($$->falseList);
		}
	|
		'(' BEXP ')' {
		  $$->trueList = $2->trueList;
		  $$->falseList = $2->falseList;
		}
;

M:    		/*epsilon*/ {
                  $$->quad = nextquad();
                }
;

N:    		/*epsilon*/ {
                  $$->nextList.push_back(nextquad());
		  emit((string)"UJUMP" + " ___");
                }
;

EXP: 
		EXP ADD_OP EXP {
		  // EXP->place is always in register!
		  if(isUsedIntReg($1->place) && isUsedIntReg($3->place)) {
		    $$->place = getIntReg();
		    emit("ADD2I " + $$->place + " " + $1->place + " " + $2->place);
		  } else if(isUsedRealReg($1->place) && isUsedRealReg($3->place)) {
		    $$->place = getRealReg();
		    emit("ADD2R " + $$->place + " " + $1->place + " " + $2->place);
		  } else {
		    semanticError("type missmatch within add operation");
		  }
		}
	|
		EXP MUL_OP EXP {
		  if(isUsedIntReg($1->place) && isUsedIntReg($3->place)) {
		    $$->place = getIntReg();
		    emit("MULTI " + $$->place + " " + $1->place + " " + $2->place);
		  } else if(isUsedRealReg($1->place) && isUsedRealReg($3->place)) {
		    $$->place = getRealReg();
		    emit("MULTR " + $$->place + " " + $1->place + " " + $2->place);
		  } else {
		    semanticError("type missmatch within mul operation");
		  }
		}
	|
		'(' EXP ')' {
		  $$->place = $2->place;
		}
	|
		'(' TYPE ')' EXP {
		  if($2->tokenValue == "Integer") {
		    if(isUsedIntReg($4->place)) {
		      $$->place = $4->place;
		    } else if(isUsedRealReg($4->place)) {
		      $$->place = getIntReg();
		      emit("CRTOI " + $$->place + " " + $4->place);
		    }
		  } else if($2->tokenValue == "Real") {
		    if(isUsedRealReg($4->place)) {
		      $$->place = $4->place;
		    } else if(isUsedIntReg($4->place)) {
		      $$->place = getRealReg();
		      emit("CITOR " + $$->place + " " + $4->place);
		    }
		  } else {
		    semanticError("undefined explicit cast");
		  }
		}
	|
		ID {
		  $$->place = $$->tokenValue;
		}
	|
		STREF {
		  $$->place = $1->place;
		}
	|
		NUM {
		  if(isInteger($1->tokenValue)) {
		    $$->place = getIntReg();
			emit("COPYI " + $$->place + " " + $1->tokenValue);
		  }
		  else {
		    $$->place = getRealReg();
			emit("COPYR " + $$->place + " " + $1->tokenValue);
		  }
		}
	|
		CALL {
		  $$->place = $1->place;
		}
;	
STREF: 
		ID '[' ID ']' {
		  // check if $1 is a variable of type defstruct
		  Variable* var = currBlock->getScopeVariable($1->tokenValue);
		  if(!var) {
		    semanticError("");
		  }
		  if(var->getType() == "defstruct") {
		    
			Variable* field;
			// get the value if var[field] from memory
		  } else {
		    semanticError($1->tokenValue + " of type " + var->getType + " is not subscriptable");
		  }
		}
	|
		STREF '[' ID ']' {
		}
;	
CALL: 
		Call ID '(' CALL_ARGS_FULL ')' {
		}
;	
CALL_ARGS_FULL: 
		CALL_ARGS {
		}
	|
		/*epsilon*/
		/*epsilon*/ {}
;	
CALL_ARGS:
		EXP {
		}
	|
		CALL_ARGS ',' EXP {
		}
;
	
%%

extern char* yytext;
extern int yylineno;

void yyerror (char const *err){
   printf("Syntax error: '%s' in line number %d\n", yytext, yylineno);
   exit(1);
}

void semanticError(string s) {
  printf("Semantic error: '%s' in line number %d\n", s.c_str(), yylineno);
  exit(1);
}
